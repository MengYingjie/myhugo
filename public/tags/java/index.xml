<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Example Site</title>
    <link>https://example.com/tags/java/</link>
    <description>Recent content in java on Example Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Mar 2021 09:50:50 +0000</lastBuildDate><atom:link href="https://example.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>test2</title>
      <link>https://example.com/p/test2/</link>
      <pubDate>Sun, 07 Mar 2021 09:50:50 +0000</pubDate>
      
      <guid>https://example.com/p/test2/</guid>
      <description>📋两种内部类用法 static class Outer { class Inner {} static class StaticInner {} } Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); Outer.StaticInner inner0 = new Outer.StaticInner(); 🤔为什么设计内部类 1 在一个类内部，需要操作某种属性，而这个属性需要涉及的面又很广，我们可以考虑，将这些属性设计为内部类。
2 好比你设计类 B 的目的只是为了给类 A 使用，那么，我们就可将其设定为内部类，没有必要将类 B 设置成单独的 Java 文件，防止与其他类产生依赖关系。
🎲解释 根据Oracle官方的说法： Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.</description>
    </item>
    
    <item>
      <title>Java中的Format时间和时间戳</title>
      <link>https://example.com/p/java%E4%B8%AD%E7%9A%84format%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3/</link>
      <pubDate>Sun, 07 Mar 2021 09:50:40 +0000</pubDate>
      
      <guid>https://example.com/p/java%E4%B8%AD%E7%9A%84format%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3/</guid>
      <description>🧐format时间和时间戳 Timestamp就是所谓的时间戳。这个主要用在数据库上，你可以再java.sql这个包内找到这个类。
一般数据库里如果用Date这个类的话，那你取出来的时候只能到某一天，也就是日，但是Timestamp的话，就是到小时一直到纳秒，很精确的。
时间戳就是一种类型，只是精度很高，比datetime要精确的多，通常用来防止数据出现脏读现象 。
时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数
🔃java中format时间和时间戳的转换 import java.text.SimpleDateFormat; import java.util.Date; /** * @author MengYingjie * @version 1.0 * @date 2020/10/26 21:33 */ public class Test2 { public static void main(String[] args) { Long SystemTimeStamp = System.currentTimeMillis(); System.out.println(&amp;#34;时间:&amp;#34; + SystemTimeStamp); String timeFormat = stampToDate(SystemTimeStamp); System.out.println(&amp;#34;时间戳转换为时间:&amp;#34; + timeFormat); Long timeStamp = dateToStamp(timeFormat); System.out.println(&amp;#34;时间转换为时间戳:&amp;#34; + timeStamp); } /** * 将时间转换为时间戳 * * @param timeFormat format 时间格式 * @return 时间戳时间格式 */ public static Long dateToStamp(String timeFormat) { SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); Long timeStamp = null; try { timeStamp = sdf.</description>
    </item>
    
    <item>
      <title>🤔为什么JAVA内部类要设计成静态和非静态</title>
      <link>https://example.com/p/%E4%B8%BA%E4%BB%80%E4%B9%88java%E5%86%85%E9%83%A8%E7%B1%BB%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E9%9D%99%E6%80%81%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81/</link>
      <pubDate>Sun, 07 Mar 2021 09:50:40 +0000</pubDate>
      
      <guid>https://example.com/p/%E4%B8%BA%E4%BB%80%E4%B9%88java%E5%86%85%E9%83%A8%E7%B1%BB%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E9%9D%99%E6%80%81%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81/</guid>
      <description>📋两种内部类用法 static class Outer { class Inner {} static class StaticInner {} } Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); Outer.StaticInner inner0 = new Outer.StaticInner(); 🤔为什么设计内部类 1 在一个类内部，需要操作某种属性，而这个属性需要涉及的面又很广，我们可以考虑，将这些属性设计为内部类。
2 好比你设计类 B 的目的只是为了给类 A 使用，那么，我们就可将其设定为内部类，没有必要将类 B 设置成单独的 Java 文件，防止与其他类产生依赖关系。
🎲解释 根据Oracle官方的说法： Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.</description>
    </item>
    
    <item>
      <title>🔑json到Object到具体对象</title>
      <link>https://example.com/p/json%E5%88%B0object%E5%88%B0%E5%85%B7%E4%BD%93%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Tue, 02 Mar 2021 09:39:50 +0000</pubDate>
      
      <guid>https://example.com/p/json%E5%88%B0object%E5%88%B0%E5%85%B7%E4%BD%93%E5%AF%B9%E8%B1%A1/</guid>
      <description>🏡环境 SpringBoot + lombok
📋遇到需求 大概意思
给出一个参数通过URI接收一个对象test（可能是两种类的对象）和一个type（判断test类型）
🌌假设： 如果type为0，test为TestTest对象，
如果type为1，test为TestTest2对象
🔬实现过程： TestTest.class和TestTest2.class
@Data @Accessors(chain = true) public class TestTest { String abc; String aaa; TestTest2 test2; } @Data @Accessors(chain = true) public class TestTest2 { String ddd; String ccc; } Controler
@RestController @RequestMapping(&amp;#34;/api/v1&amp;#34;) public class TestController { private final Logger log = LoggerFactory.getLogger(TestController.class); @PostMapping(&amp;#34;/hello&amp;#34;) public String helloWorld(String type, @RequestBody Object test) throws IOException { log.info(&amp;#34;test {}&amp;#34;, test.toString()); if (type.equals(&amp;#34;0&amp;#34;)) { TestTest testTest = new TestTest(); ObjectMapper objectMapper = new ObjectMapper(); String testString = objectMapper.</description>
    </item>
    
  </channel>
</rss>
